#
# This file is auto-generated by puppet. DO NOT EDIT as your changes WILL be
# automatically reverted and lost. You have been warned.
#

# Filter table, the main one
*filter
:INPUT DROP [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:CLOSED - [0:0]
<% @chains_filter.sort_by {|key,value| key}.each do |key,value| -%>
:<%= key %> - [0:0]
<% end -%>
<% if @knock -%>
:KNOCK-INPUT - [0:0]
:KNOCK-MAIN - [0:0]
<% end -%>
-A INPUT -i lo -j ACCEPT
<% if @protectpriv -%>
# Drop "private" packets arriving on the public interface
# (we don't want to be doing that if we only have a single private interface!)
-A INPUT -i <%= @ethpub -%> -s 10.0.0.0/8 -j DROP
-A INPUT -i <%= @ethpub -%> -s 172.16.0.0/12 -j DROP
-A INPUT -i <%= @ethpub -%> -s 192.168.0.0/16 -j DROP
<% end -%>
<% @raw_rules_filter.each do |line| -%>
<%= line %>
<% end -%>
<% if !@vrrp.empty? -%>
<% @vrrp.each do |int| -%>
-A INPUT -i <%= int -%> -p vrrp -j ACCEPT
<% end -%>
<% end -%>
<% if @ospf -%>
<% @ospf.each do |int| -%>
-A INPUT -i <%= int %> -p ospf -j ACCEPT
<% end -%>
<% end -%>
<% @tcpports.each do |port| -%>
-A INPUT -p tcp -m tcp --dport <%= port %> -j ACCEPT
<% end -%>
<% @srctcpports.sort_by {|key, value| key}.each do |key,value| -%>
<% value.each do |src| -%>
-A INPUT -p tcp -m tcp -s <%= src %> --dport <%= key %> -j ACCEPT
<% end -%>
<% end -%>
<% @srcudpports.sort_by {|key, value| key}.each do |key,value| -%>
<% value.each do |src| -%>
-A INPUT -p udp -m udp -s <%= src %> --dport <%= key %> -j ACCEPT
<% end -%>
<% end -%>
<% @udpports.each do |port| -%>
-A INPUT -p udp -m udp --dport <%= port %> -j ACCEPT
<% end -%>
<% @lsnraddrs.each do |lsnraddr| -%>
-A INPUT -s <%= lsnraddr %> -p tcp -m tcp --dport 1521:1531 -j ACCEPT
<% end -%>
<% @sipaddrs.each do |sipaddr| -%>
-A INPUT -s <%= sipaddr %> -p udp -m udp --dport 5060 -j ACCEPT
<% end -%>
<% @privtcpports.each do |port| -%>
-A INPUT -i <%= @ethpriv %> -p tcp -m tcp --dport <%= port %> -j ACCEPT
-A INPUT -i tun+ -p tcp -m tcp --dport <%= port %> -j ACCEPT
<% end -%>
<% @privudpports.each do |port| -%>
-A INPUT -i <%= @ethpriv %> -p udp -m udp --dport <%= port %> -j ACCEPT
-A INPUT -i tun+ -p udp -m udp --dport <%= port %> -j ACCEPT
<% end -%>
<% if @hosts_ssh -%>
# Accept ssh connections from a limited number of networks
<% @hosts_ssh.each do |host| -%>
-A INPUT -s <%= host %> -p tcp -m tcp --dport 22 -j ACCEPT
<% end -%>
<% end -%>
<% if @hosts_nrpe -%>
# Accept nrpe connections from the nagios server
<% @hosts_nrpe.each do |host| -%>
-A INPUT -s <%= host %> -p tcp -m tcp --dport 5666 -j ACCEPT
<% end -%>
<% end -%>
<% if @hosts_snmp -%>
# Accept snmp connections from the main graphing server + LANs
<% @hosts_snmp.each do |host| -%>
-A INPUT -s <%= host %> -p udp -m udp --dport 161 -j ACCEPT
<% end -%>
<% end -%>
<% if @openvpn -%>
# Accept OpenVPN connections from a limited number of networks
<% @openvpn_host.each do |host| -%>
-A INPUT -s <%= host %> -i <%= @ethpub %> -p <%= @openvpn_prot %> -m <%= @openvpn_prot %> --dport <%= @openvpn_port %> -j ACCEPT
<% end -%>
<% end -%>
# Stateful firewall (beware of filling up the connection tracking table)
-A INPUT <%= @mstate %> RELATED,ESTABLISHED -j ACCEPT
<% if @icmp_limit_enable -%>
# Limit ICMP requests globally (prevent DoS)
-A INPUT -p icmp -m icmp --icmp-type timestamp-request -j DROP
-A INPUT -p icmp -m limit --limit <%= @icmp_limit %> -j ACCEPT
-A INPUT -p icmp -j DROP
<% else -%>
# Accept all ICMP
-A INPUT -p icmp -j ACCEPT
<% end -%>
# Reject known "crappy ports" connections to avoid logging overhead
-A INPUT -p tcp -m multiport --dports 135,137,138,139,445,1026 -j CLOSED
-A INPUT -p udp -m multiport --dports 135,137,138,139,445,1026,17500 -j CLOSED
# Drop broadcast DHCP messages
-A INPUT -p udp -m udp --sport 68 --dport 67 -j DROP
-A INPUT -p udp -m udp --sport 67 --dport 68 -j DROP
# Drop multicast messages
-A INPUT -p igmp -d 224.0.0.1 -j DROP
<% if @vrrp.empty? -%>
# Drop broadcard VRRP messages
-A INPUT -p vrrp -j DROP
<% end -%>
<% if @knock -%>
# Port knocking
-A INPUT -j KNOCK-MAIN
<% end -%>
# Log to syslog kern.debug
-A INPUT -j LOG --log-level 7
# Default to sending "connection refused" messages instead of silently dropping
-A INPUT -j CLOSED
<% if @icmp_limit_enable -%>
# Limit ICMP replies globally (prevent DoS)
-A OUTPUT -p icmp -m limit --limit <%= @icmp_limit %> -j ACCEPT
-A OUTPUT -p icmp -j DROP
<% end -%>
# Custom table to send back "connection refused" messages
-A CLOSED -j REJECT --reject-with icmp-port-unreachable
<% if @knock -%>
# Port knocking magic
-A KNOCK-INPUT -m recent --set --name KNOCK1 --rsource -j CLOSED
<% @knocktcpopen.each do |port| -%>
-A KNOCK-MAIN -p tcp <%= @mstate %> NEW -m tcp --dport <%= port %> -m recent --rcheck --name KNOCK1 --rsource -j ACCEPT
<% end -%>
-A KNOCK-MAIN -p tcp -m tcp ! --dport <%= @knocktwo %> <%= @mstate %> NEW -m recent --remove --name KNOCK1 --rsource -j CLOSED
-A KNOCK-MAIN -p tcp <%= @mstate %> NEW -m tcp --dport <%= @knocktwo %> -m recent --rcheck --name KNOCK0 --rsource -j KNOCK-INPUT
-A KNOCK-MAIN -p tcp -m tcp ! --dport <%= @knockone %> <%= @mstate %> NEW -m recent --remove --name KNOCK0 --rsource -j CLOSED
-A KNOCK-MAIN -p tcp <%= @mstate %> NEW -m tcp --dport <%= @knockone %> -m recent --set --name KNOCK0 --rsource -j CLOSED
<% end -%>
<% @chains_filter.sort_by {|key, value| key}.each do |key,value| -%>
<% value.each do |line| -%>
-A <%= key %> <%= line %>
<% end -%>
<% end -%>
COMMIT
<% if @masq or !@raw_rules_nat.empty? or !@redirect_tcp_port.empty? or !@dnat_tcp_port.empty? -%>

# NAT table, used for masquerading and DNAT
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
<% @raw_rules_nat.each do |line| -%>
<%= line %>
<% end -%>
<% if !@redirect_tcp_port.empty? -%>
<% @redirect_tcp_port.sort_by {|key, value| key}.each do |key,value| -%>
# Redirect TCP traffic arriving on port <%= key %> to local port <%= value %>
-A PREROUTING -p tcp -m tcp --dport <%= key %> -j REDIRECT --to-ports <%= value %>
<% end -%>
<% end -%>
<% if !@dnat_tcp_port.empty? -%>
<% @dnat_tcp_port.sort_by {|key, value| key}.each do |key,value| -%>
# Redirect TCP traffic arriving on port <%= key %> to remote <%= value %>
-A PREROUTING -p tcp -m tcp --dport <%= key %> -j DNAT --to-destination <%= value %>
<% end -%>
<% end -%>
<% if @masq -%>
-A POSTROUTING -s 10.0.0.0/8 -o <%= @ethpub -%> -j MASQUERADE
-A POSTROUTING -s 172.16.0.0/12 -o <%= @ethpub -%> -j MASQUERADE
-A POSTROUTING -s 192.168.0.0/16 -o <%= @ethpub -%> -j MASQUERADE
<% end -%>
COMMIT
<% end -%>
<% if not @fwmark.empty? -%>

# MANGLE table, used for marking packets
*mangle
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
<% @fwmark.sort_by {|key, value| key}.each do |key,value| -%>
<% value.each do |markrule| -%>
-A PREROUTING <%= markrule %> -j MARK --set-mark <%= key %>
<% end -%>
<% end -%>
COMMIT
<% end -%>
